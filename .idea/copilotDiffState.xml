<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Services/Gestion_covoiturage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Services/Gestion_covoiturage.java" />
              <option name="originalContent" value="package Services;&#10;&#10;import Models.*;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Vector;&#10;&#10;/**&#10; * Gestion_covoiturage&#10; * -------------------&#10; * Classe centrale de gestion du système de covoiturage.&#10; * Elle constitue un gestionnaire en mémoire des utilisateurs (drivers et passengers),&#10; * des trajets disponibles, des demandes effectuées par les passagers et des passagers&#10; * acceptés. Cette classe fournit une API utilisée par l'interface graphique pour&#10; * rechercher des utilisateurs, créer/supprimer des demandes et accepter des passagers&#10; * sur des trajets.&#10; *&#10; * Principales responsabilités :&#10; * - maintenir les collections d'objets (users, trajets, demandes, passagers acceptés)&#10; * - exposer des méthodes utilitaires pour l'UI (recherche, ajout/suppression de demandes,&#10; *   acceptation de passagers)&#10; * - veiller à la cohérence des structures (mise à jour des places disponibles, mapping&#10; *   demandes_par_conducteur, historique des passagers acceptés, statut des trajets)&#10; */&#10;public class Gestion_covoiturage {&#10;    private int Index_trajet_conducteur = -1;&#10;    private int Index_conducteur = -1;&#10;    private int Index_passager = -1;&#10;    private Vector&lt;User&gt; users = new Vector&lt;&gt;();&#10;    private Vector&lt;Trajet&gt; trajets = new Vector&lt;&gt;();&#10;    private Vector&lt;User&gt; passagers_acceptes = new Vector&lt;&gt;();&#10;    // demandes par conducteur : clé = CIN du conducteur, valeur = liste des CINs des passagers ayant demandé ce conducteur&#10;    private Map&lt;String, Vector&lt;String&gt;&gt; demandes_par_conducteur = new HashMap&lt;&gt;();&#10;&#10;    // Getters&#10;    public Vector&lt;User&gt; getUsers() { return users; }&#10;    public Vector&lt;Trajet&gt; getTrajets() { return trajets; }&#10;    public Vector&lt;User&gt; getPassagers_acceptes() { return passagers_acceptes; }&#10;&#10;    // Setters&#10;    public void setUsers(Vector&lt;User&gt; users) { this.users = users; }&#10;    public void setTrajets(Vector&lt;Trajet&gt; trajets) { this.trajets = trajets; }&#10;&#10;    // ===== Recherche d'utilisateurs =====&#10;&#10;    /**&#10;     * Recherche un utilisateur par son CIN&#10;     */&#10;    public User rechercher_user(String ref) {&#10;        for (User U : users) {&#10;            if (U.getCin().equalsIgnoreCase(ref)) {&#10;                return U;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Recherche un conducteur par son CIN&#10;     */&#10;    public Conducteur rechercher_conducteur(String cin) {&#10;        User user = rechercher_user(cin);&#10;        if (user != null &amp;&amp; user instanceof Conducteur) {&#10;            return (Conducteur) user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Recherche un passager par son CIN&#10;     */&#10;    public Passager rechercher_passager(String cin) {&#10;        User user = rechercher_user(cin);&#10;        if (user != null &amp;&amp; user instanceof Passager) {&#10;            return (Passager) user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // ===== API utilisée par l'UI (gestion des demandes / acceptations) =====&#10;&#10;    /**&#10;     * Ajouter une demande pour un conducteur&#10;     */&#10;    public void ajouter_demande_pour_conducteur(String cinConducteur, String cinPassager) {&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.computeIfAbsent(cinConducteur, k -&gt; new Vector&lt;&gt;());&#10;        if (!demandes.contains(cinPassager)) {&#10;            demandes.add(cinPassager);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Supprimer une demande pour un conducteur&#10;     */&#10;    public void supprimer_demande_pour_conducteur(String cinConducteur, String cinPassager) {&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.get(cinConducteur);&#10;        if (demandes != null) {&#10;            demandes.removeIf(s -&gt; s.equalsIgnoreCase(cinPassager));&#10;            if (demandes.isEmpty()) {&#10;                demandes_par_conducteur.remove(cinConducteur);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ajouter une demande pour un trajet spécifique&#10;     */&#10;    public boolean ajouter_demande_pour_trajet(Trajet t, String cinPassager) {&#10;        if (t == null || cinPassager == null || cinPassager.trim().isEmpty()) return false;&#10;        Passager p = rechercher_passager(cinPassager);&#10;        if (p == null) return false;&#10;&#10;        // Ajouter dans la liste du trajet&#10;        boolean added = t.addDemand(p);&#10;        // Mettre à jour mapping demandes_par_conducteur pour affichage rapide&#10;        if (t.getConducteur() != null) {&#10;            Vector&lt;String&gt; demandes = demandes_par_conducteur.computeIfAbsent(t.getConducteur().getCin(), k -&gt; new Vector&lt;&gt;());&#10;            if (!demandes.contains(cinPassager)) demandes.add(cinPassager);&#10;        }&#10;        return added;&#10;    }&#10;&#10;    /**&#10;     * Accepter un passager pour un trajet&#10;     * Retourne true si l'acceptation a réussi.&#10;     */&#10;    public boolean accepter_passager_pour_trajet(Trajet t, String cinPassager) {&#10;        if (t == null || cinPassager == null || cinPassager.trim().isEmpty()) return false;&#10;        if (t.getConducteur() == null) return false;&#10;&#10;        Passager p = rechercher_passager(cinPassager);&#10;        if (p == null) return false;&#10;&#10;        // Use the conducteur associated with the trajet&#10;        Conducteur conducteur = t.getConducteur();&#10;&#10;        // Vérifier places disponibles au niveau du trajet&#10;        if (t.getAvailablePlaces() &lt;= 0) return false;&#10;&#10;        // Essayer d'accepter via l'objet trajet&#10;        boolean accepted = t.acceptPassenger(p);&#10;        if (!accepted) return false;&#10;&#10;        // Mark passenger as no longer searching -&gt; reserved&#10;        try {&#10;            p.setChercheCovoit(false);&#10;        } catch (Exception ignored) {}&#10;&#10;        // Mettre à jour places du conducteur global&#10;        try {&#10;            conducteur.setPlacesDisponibles(Math.max(0, conducteur.getPlacesDisponibles() - 1));&#10;        } catch (Exception ignored) {}&#10;&#10;        // Retirer de mapping demandes_par_conducteur&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.get(conducteur.getCin());&#10;        if (demandes != null) demandes.remove(cinPassager);&#10;&#10;        // Ajouter à historique global&#10;        passagers_acceptes.add(p);&#10;&#10;        // Mise à jour statut et validité&#10;        t.setTrajet_valide(true);&#10;        if (!t.getPassagersAcceptes().isEmpty()) t.setStatusTrajet(Trajet.STATUS_IN_PROGRESS);&#10;&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package Services;&#10;&#10;import Models.*;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Vector;&#10;&#10;/**&#10; * Gestion_covoiturage&#10; * -------------------&#10; * Classe centrale de gestion du système de covoiturage.&#10; * Elle constitue un gestionnaire en mémoire des utilisateurs (drivers et passengers),&#10; * des trajets disponibles, des demandes effectuées par les passagers et des passagers&#10; * acceptés. Cette classe fournit une API utilisée par l'interface graphique pour&#10; * rechercher des utilisateurs, créer/supprimer des demandes et accepter des passagers&#10; * sur des trajets.&#10; *&#10; * Principales responsabilités :&#10; * - maintenir les collections d'objets (users, trajets, demandes, passagers acceptés)&#10; * - exposer des méthodes utilitaires pour l'UI (recherche, ajout/suppression de demandes,&#10; *   acceptation de passagers)&#10; * - veiller à la cohérence des structures (mise à jour des places disponibles, mapping&#10; *   demandes_par_conducteur, historique des passagers acceptés, statut des trajets)&#10; */&#10;public class Gestion_covoiturage {&#10;    private int Index_trajet_conducteur = -1;&#10;    private int Index_conducteur = -1;&#10;    private int Index_passager = -1;&#10;    private Vector&lt;User&gt; users = new Vector&lt;&gt;();&#10;    private Vector&lt;Trajet&gt; trajets = new Vector&lt;&gt;();&#10;    private Vector&lt;User&gt; passagers_acceptes = new Vector&lt;&gt;();&#10;    // demandes par conducteur : clé = CIN du conducteur, valeur = liste des CINs des passagers ayant demandé ce conducteur&#10;    private Map&lt;String, Vector&lt;String&gt;&gt; demandes_par_conducteur = new HashMap&lt;&gt;();&#10;&#10;    // Getters&#10;    public Vector&lt;User&gt; getUsers() { return users; }&#10;    public Vector&lt;Trajet&gt; getTrajets() { return trajets; }&#10;    public Vector&lt;User&gt; getPassagers_acceptes() { return passagers_acceptes; }&#10;&#10;    // Setters&#10;    public void setUsers(Vector&lt;User&gt; users) { this.users = users; }&#10;    public void setTrajets(Vector&lt;Trajet&gt; trajets) { this.trajets = trajets; }&#10;&#10;    // ===== Recherche d'utilisateurs =====&#10;&#10;    /**&#10;     * Recherche un utilisateur par son CIN&#10;     */&#10;    public User rechercher_user(String ref) {&#10;        for (User U : users) {&#10;            if (U.getCin().equalsIgnoreCase(ref)) {&#10;                return U;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Recherche un conducteur par son CIN&#10;     */&#10;    public Conducteur rechercher_conducteur(String cin) {&#10;        User user = rechercher_user(cin);&#10;        if (user != null &amp;&amp; user instanceof Conducteur) {&#10;            return (Conducteur) user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Recherche un passager par son CIN&#10;     */&#10;    public Passager rechercher_passager(String cin) {&#10;        User user = rechercher_user(cin);&#10;        if (user != null &amp;&amp; user instanceof Passager) {&#10;            return (Passager) user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // ===== API utilisée par l'UI (gestion des demandes / acceptations) =====&#10;&#10;    /**&#10;     * Ajouter une demande pour un conducteur&#10;     */&#10;    public void ajouter_demande_pour_conducteur(String cinConducteur, String cinPassager) {&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.computeIfAbsent(cinConducteur, k -&gt; new Vector&lt;&gt;());&#10;        if (!demandes.contains(cinPassager)) {&#10;            demandes.add(cinPassager);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Supprimer une demande pour un conducteur&#10;     */&#10;    public void supprimer_demande_pour_conducteur(String cinConducteur, String cinPassager) {&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.get(cinConducteur);&#10;        if (demandes != null) {&#10;            demandes.removeIf(s -&gt; s.equalsIgnoreCase(cinPassager));&#10;            if (demandes.isEmpty()) {&#10;                demandes_par_conducteur.remove(cinConducteur);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ajouter une demande pour un trajet spécifique&#10;     */&#10;    public boolean ajouter_demande_pour_trajet(Trajet t, String cinPassager) {&#10;        if (t == null || cinPassager == null || cinPassager.trim().isEmpty()) return false;&#10;        Passager p = rechercher_passager(cinPassager);&#10;        if (p == null) return false;&#10;&#10;        // Ajouter dans la liste du trajet&#10;        boolean added = t.addDemand(p);&#10;        // Mettre à jour mapping demandes_par_conducteur pour affichage rapide&#10;        if (t.getConducteur() != null) {&#10;            Vector&lt;String&gt; demandes = demandes_par_conducteur.computeIfAbsent(t.getConducteur().getCin(), k -&gt; new Vector&lt;&gt;());&#10;            if (!demandes.contains(cinPassager)) demandes.add(cinPassager);&#10;        }&#10;        return added;&#10;    }&#10;&#10;    /**&#10;     * Accepter un passager pour un trajet&#10;     * Retourne true si l'acceptation a réussi.&#10;     */&#10;    public boolean accepter_passager_pour_trajet(Trajet t, String cinPassager) {&#10;        if (t == null || cinPassager == null || cinPassager.trim().isEmpty()) return false;&#10;        if (t.getConducteur() == null) return false;&#10;&#10;        Passager p = rechercher_passager(cinPassager);&#10;        if (p == null) return false;&#10;&#10;        // Use the conducteur associated with the trajet&#10;        Conducteur conducteur = t.getConducteur();&#10;&#10;        // Vérifier places disponibles au niveau du trajet&#10;        if (t.getAvailablePlaces() &lt;= 0) return false;&#10;&#10;        // Essayer d'accepter via l'objet trajet&#10;        boolean accepted = t.acceptPassenger(p);&#10;        if (!accepted) return false;&#10;&#10;        // Mark passenger as no longer searching -&gt; reserved&#10;        try {&#10;            p.setChercheCovoit(false);&#10;        } catch (Exception ignored) {}&#10;&#10;        // Mettre à jour places du conducteur global&#10;        try {&#10;            conducteur.setPlacesDisponibles(Math.max(0, conducteur.getPlacesDisponibles() - 1));&#10;        } catch (Exception ignored) {}&#10;&#10;        // Retirer de mapping demandes_par_conducteur&#10;        Vector&lt;String&gt; demandes = demandes_par_conducteur.get(conducteur.getCin());&#10;        if (demandes != null) demandes.remove(cinPassager);&#10;&#10;        // Ajouter à historique global&#10;        passagers_acceptes.add(p);&#10;&#10;        // Mise à jour statut et validité&#10;        t.setTrajet_valide(true);&#10;        if (!t.getPassagersAcceptes().isEmpty()) t.setStatusTrajet(Trajet.STATUS_IN_PROGRESS);&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>